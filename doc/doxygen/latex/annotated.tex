\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_abstract_gem}{Abstract\+Gem} \\*Our base class of all gems.  As base class all required information of a gem are stored. Also usefull algorithms for collision detection are provided. Furthermore this class is supposed to be used within Q\+M\+L }{\pageref{class_abstract_gem}}{}
\item\contentsline{section}{\hyperlink{class_blur_effect}{Blur\+Effect} \\*The \hyperlink{class_blur_effect}{Blur\+Effect} blurs a given texture }{\pageref{class_blur_effect}}{}
\item\contentsline{section}{\hyperlink{class_camera}{Camera} \\*View and perspective projection matrices. Additional the viewport of camera is stored.  The view of camera has to be specified by eye, center and up or by position, viewdirection and up. It is allowed to mix both definitions, but it might lead to unexpected behaviour. The perspective projection is specified by field of view, viewport, and near and far plane }{\pageref{class_camera}}{}
\item\contentsline{section}{\hyperlink{class_config}{Config} \\*Easy access to values read out of our config.\+json provided by Config\+View.\+qml.  The config class is implemented as singleton, because these values are used in many various situations. This class works together Config\+View.\+qml }{\pageref{class_config}}{}
\item\contentsline{section}{\hyperlink{class_cube_gem}{Cube\+Gem} \\*Cube\+Gems are gems with a shape like a cube. The only difference to Abstrac\+Gem is the fact, that a cube gem has a shape defined }{\pageref{class_cube_gem}}{}
\item\contentsline{section}{\hyperlink{class_cube_map}{Cube\+Map} \\*Loads cubemap textures and provides them as Open\+G\+L-\/texture }{\pageref{class_cube_map}}{}
\item\contentsline{section}{\hyperlink{class_environment_map}{Environment\+Map} \\*The \hyperlink{class_environment_map}{Environment\+Map} is a \hyperlink{class_cube_map}{Cube\+Map} based rendering technique for showing some scene enviroment }{\pageref{class_environment_map}}{}
\item\contentsline{section}{\hyperlink{class_file_i_o}{File\+I\+O} \\*Platform independent file reading for ressource files used by us.  The file that should be read is specified by name and \hyperlink{class_file_i_o}{File\+I\+O} will load it from platform dependent location }{\pageref{class_file_i_o}}{}
\item\contentsline{section}{\hyperlink{class_game_lost_ray}{Game\+Lost\+Ray} \\*Specialized \hyperlink{class_light_ray}{Light\+Ray}, that is created if the player should loose as soon as the player reaches it }{\pageref{class_game_lost_ray}}{}
\item\contentsline{section}{\hyperlink{class_gem_data}{Gem\+Data} \\*Stores all required information to describe a \hyperlink{class_abstract_gem}{Abstract\+Gem}.  The adventage of \hyperlink{class_gem_data}{Gem\+Data} is, that it is possible to assign, copy, compare and \hyperlink{abstractgem_8cpp_a92fb5a3a6f53f07f0f9653dd299d31ff}{q\+Hash()} this class. Therefore it is possible to store it in most Qt-\/containers }{\pageref{class_gem_data}}{}
\item\contentsline{section}{\hyperlink{class_gem_renderer}{Gem\+Renderer} \\*Renders all of our gems.  For performance reasons the \hyperlink{class_gem_renderer}{Gem\+Renderer} packs all gems and fakes instanced drawing }{\pageref{class_gem_renderer}}{}
\item\contentsline{section}{\hyperlink{class_highscore}{Highscore} \\*The \hyperlink{class_highscore}{Highscore} is only a semantic class. We want to clarify that this file\+I\+O is a \hyperlink{class_highscore}{Highscore} }{\pageref{class_highscore}}{}
\item\contentsline{section}{\hyperlink{class_light_ray}{Light\+Ray} \\*Describes our lightrays send into \hyperlink{class_scene}{Scene}.  Because we send our Light\+Rays into \hyperlink{class_scene}{Scene} right after creation, they are more lines but rays. Our rays are organized as a tree, a ray owns all of its \hyperlink{class_light_ray_a6673a77eb8fcd32dcfde26a1b112d303}{successors()}. Accidentally most of our game logic is done within \hyperlink{class_light_ray_acf06a71a307433fa5b220baccf809e64}{Light\+Ray\+::update()} }{\pageref{class_light_ray}}{}
\item\contentsline{section}{\hyperlink{class_light_ray_data}{Light\+Ray\+Data} \\*Stores data of a \hyperlink{class_light_ray}{Light\+Ray}. The \hyperlink{class_light_ray_data}{Light\+Ray\+Data} doesn\textquotesingle{}t inherit from Q\+Object, so it can be stored in Qt-\/\+Containers (currently only those require == or q\+Hash) by Value. Also the data can be copied easily }{\pageref{class_light_ray_data}}{}
\item\contentsline{section}{\hyperlink{class_light_ray_renderer}{Light\+Ray\+Renderer} \\*The \hyperlink{class_light_ray_renderer}{Light\+Ray\+Renderer} packs Light\+Rays and paint them }{\pageref{class_light_ray_renderer}}{}
\item\contentsline{section}{\hyperlink{class_navigation}{Navigation} \\*Interface for all navigation techniques.  The navigation takes euler angles in coordinate system based on current view and translate them into quaternions describing the changes in our world }{\pageref{class_navigation}}{}
\item\contentsline{section}{\hyperlink{class_painter}{Painter} \\*The \hyperlink{class_painter}{Painter} class  Includes the rendering process, thus creates the whole picture. The \hyperlink{class_painter}{Painter} will be used by Q\+M\+L within rendering thread }{\pageref{class_painter}}{}
\item\contentsline{section}{\hyperlink{class_painter_q_m_l}{Painter\+Q\+M\+L} \\*Responsible to make our game visible within Q\+M\+L using \hyperlink{class_painter}{Painter}.  This class is intended to be added and created within Q\+M\+L. As the element showing our game it recognizes(?) resize events and update events needed by our application. Also it keeps our rendering alive. Furthermore it is the interface between game logic and rendering }{\pageref{class_painter_q_m_l}}{}
\item\contentsline{section}{\hyperlink{class_player}{Player} \\*Our \hyperlink{class_player}{Player} class is pretty stupid, because our player only ride on lightrays. The only responsiblity is to move on rays and update the camera }{\pageref{class_player}}{}
\item\contentsline{section}{\hyperlink{class_q_hash}{Q\+Hash$<$ Key, T $>$} }{\pageref{class_q_hash}}{}
\item\contentsline{section}{\hyperlink{class_q_list}{Q\+List$<$ T $>$} }{\pageref{class_q_list}}{}
\item\contentsline{section}{\hyperlink{class_q_set}{Q\+Set$<$ T $>$} }{\pageref{class_q_set}}{}
\item\contentsline{section}{\hyperlink{classorg_1_1qtproject_1_1qt5_1_1android_1_1bindings_1_1_qt_activity}{org.\+qtproject.\+qt5.\+android.\+bindings.\+Qt\+Activity} }{\pageref{classorg_1_1qtproject_1_1qt5_1_1android_1_1bindings_1_1_qt_activity}}{}
\item\contentsline{section}{\hyperlink{class_q_vector}{Q\+Vector$<$ T $>$} }{\pageref{class_q_vector}}{}
\item\contentsline{section}{\hyperlink{class_scene}{Scene} \\*Access to geometry and collision detection methods. Furthermore some game logic is implemented, so the scene holds the player, the gem inflicted by player and cameras }{\pageref{class_scene}}{}
\item\contentsline{section}{\hyperlink{class_scene_bounds}{Scene\+Bounds} \\*Special kind of gem describing the bounds of scene. The shape of the bounds is a cube, with a given extent in each direction.  The main reason that the bounds are also a gem is easier collision detection. If we have bounds around our scene every ray emitted into scene will hit something. Furthermore the collision with scene bounds can be processed in a way, that the player will loose if the player hits the bounds }{\pageref{class_scene_bounds}}{}
\item\contentsline{section}{\hyperlink{class_scene_renderer}{Scene\+Renderer} \\*The \hyperlink{class_scene_renderer}{Scene\+Renderer} class  Renders the scene\+: Packs the scene in the buffer and draws the scene in as few render calls as possible. The \hyperlink{class_scene_renderer}{Scene\+Renderer} uses specialized Renderer for diffrent types of geometry }{\pageref{class_scene_renderer}}{}
\item\contentsline{section}{\hyperlink{class_screen_aligned_quad}{Screen\+Aligned\+Quad} \\*Encapsulates the drawing of a screen aligned quad }{\pageref{class_screen_aligned_quad}}{}
\item\contentsline{section}{\hyperlink{class_soundmanager}{Soundmanager} \\*Several sounds which can be played.  The \hyperlink{class_soundmanager}{Soundmanager} manages the required ressources }{\pageref{class_soundmanager}}{}
\item\contentsline{section}{\hyperlink{class_tetrahedron_gem}{Tetrahedron\+Gem} \\*Tetrahedron\+Gems are gems with a shape like a tetrahedron. The only difference to Abstrac\+Gem is the fact, that a \hyperlink{class_tetrahedron_gem}{Tetrahedron\+Gem} has a shape defined }{\pageref{class_tetrahedron_gem}}{}
\item\contentsline{section}{\hyperlink{class_triangle}{Triangle} \\*\hyperlink{class_triangle}{Triangle} in three dimensional space }{\pageref{class_triangle}}{}
\end{DoxyCompactList}
